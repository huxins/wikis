# 线程基础

## 线程使用方式

### 实现 Runnable 接口

```java
class RunnableImpl implements Runnable {
    public void run() {
        // ...
    }
}
```

```java
new Thread(new RunnableImpl()).start();
```

- 函数式接口

```java
new Thread(() -> {
    // ...
}).start();
```

### 实现 Callable 接口

```java
class CallableImpl implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
```

```java
FutureTask<Integer> ft = new FutureTask<>(new CallableImpl());
new Thread(ft).start();
System.out.println(ft.get());
```

### 继承 Thread 类

同样需要实现 `run()` 方法，因为 Thread 类实现了 Runable 接口。

```java
class SubThread extends Thread {
    public void run() {
        // ...
    }
}
```

```java
new SubThread().start();
```

- 匿名类

```java
new Thread() {
    public void run() {
        // ...
    }
}.start();
```

### 实现接口 VS 继承 Thread

- 实现 Runnable 接口相比继承 Thread 类有如下优势
  - 可以避免由于 Java 的单继承特性而带来的局限
  - 代码能够被多个线程共享
  - 线程池只能放入实现 Runable 或 Callable 的类

- 实现 Runnable 接口和实现 Callable 接口的区别
  - Runnable 从 java 1.1 就有，Callable 是 1.5 之后加上去的
  - 实现 Callable 接口的任务线程能返回执行结果
  - Callable 接口的 call() 方法允许抛出异常，而 Runnable 接口的 run() 方法的异常只能在内部消化，不能继续上抛
  - 加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法

## 线程状态转换

![线程状态转换](https://static-wiki.inxiny.cn/Java/Java%20SE/Thread/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)

### New

新建状态，创建后尚未启动

### Runnable

可运行状态，可能正在运行，也可能正在等待 CPU 时间片。

包含了操作系统线程状态中的 Running 和 Ready。

### Blocking

阻塞状态，等待获取一个排它锁，如果其线程释放了锁就会结束此状态。

### Waiting

无限期等待状态，等待其他线程显式地唤醒，否则不会被分配 CPU 时间片。

### Timed Waiting

限期等待状态。

## 线程阻塞

### 同步阻塞

运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入“锁池”中。

### 等待阻塞

运行的线程执行 `wait()` 方法，该线程会释放占用的所有资源，JVM 会把该线程放入“等待池”中。

进入这个状态后，无法自动唤醒，必须由其他线程调用 `notify()` 或 `notifyAll()` 方法才能将其唤醒。

### 其他阻塞

运行的线程执行 `sleep()` 或 `join()` 方法，或者发出了 I/O 请求时，JVM 会把该线程置为阻塞状态。

当 `sleep()` 状态超时、`join()` 等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入就绪状态。

## 线程中断

`interrupt()` 方法并不能立即中断线程，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于线程内部逻辑。

线程的 `isInterrupted()` 方法可以检测 `请求中断标志` 为 true 还是 false。

静态方法 `interrupted()` 也可以检测标志，但检测完以后会自动将 `请求中断标志` 置为 false。

部分可中断的线程方法（如 Object.wait, Thread.sleep），会定期执行 `isInterrupted()` 方法，检测到变化，会停止阻塞并抛出 InterruptedException 异常。

在捕获 InterruptedException 异常的时候会自动将 `请求中断标志` 置为 false。

`stop()` 废弃原因：强制让线程停止有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了解锁，导致数据得不到同步的处理，出现数据不一致的问题。

