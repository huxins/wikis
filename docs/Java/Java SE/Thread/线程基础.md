# 线程基础

## 线程使用方式

### 实现 Runnable 接口

```java
class RunnableImpl implements Runnable {
    public void run() {
        // ...
    }
}
```

```java
new Thread(new RunnableImpl()).start();
```

- 函数式接口

```java
new Thread(() -> {
    // ...
}).start();
```

### 实现 Callable 接口

```java
class CallableImpl implements Callable<Integer> {
    public Integer call() {
        return 123;
    }
}
```

```java
FutureTask<Integer> ft = new FutureTask<>(new CallableImpl());
new Thread(ft).start();
System.out.println(ft.get());
```

### 继承 Thread 类

同样需要实现 `run()` 方法，因为 Thread 类实现了 Runable 接口。

```java
class SubThread extends Thread {
    public void run() {
        // ...
    }
}
```

```java
new SubThread().start();
```

- 匿名类

```java
new Thread() {
    public void run() {
        // ...
    }
}.start();
```

### 实现接口 VS 继承 Thread

- 实现 Runnable 接口相比继承 Thread 类有如下优势
  - 可以避免由于 Java 的单继承特性而带来的局限
  - 代码能够被多个线程共享
  - 线程池只能放入实现 Runable 或 Callable 的类

- 实现 Runnable 接口和实现 Callable 接口的区别
  - Runnable 从 java 1.1 就有，Callable 是 1.5 之后加上去的
  - 实现 Callable 接口的任务线程能返回执行结果
  - Callable 接口的 call() 方法允许抛出异常，而 Runnable 接口的 run() 方法的异常只能在内部消化，不能继续上抛
  - 加入线程池运行，Runnable 使用 ExecutorService 的 execute 方法，Callable 使用 submit 方法

